{% func Stores(input *StoresInput) %}
// Code generated by ormgen; DO NOT EDIT.

package {%s input.Package.Name %}

import (
	"context"
	"github.com/pkg/errors"
	
	"github.com/setare/orm"
	"github.com/setare/orm/query"

{% if !input.ModelsPackage.Equals(input.Package) %}
	"{%s input.ModelsPackage.ImportPath %}"
{% endif %}
)

{% for _, record := range input.Records -%}
type {%s record.Store.Type %} struct {
	conn orm.Connection
}

func New{%s record.Store.Type %}(conn orm.Connection) *{%s record.Store.Type %} {
	return &{%s record.Store.Type %}{
		conn,
	}
}

func (store *{%s record.Store.Type%}) Insert(record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) error {
	return store.InsertContext(context.Background(), record, fields...)
}

func (store *{%s record.Store.Type%}) InsertContext(ctx context.Context, record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) error {
	if len(fields) == 0 {
		fields = {%s record.Schema.InternalRef %}Fields
	}

	var recordItf interface{} = record

	if biH, ok := recordItf.(orm.HookBeforeInsert); ok {
		err := biH.BeforeInsert(ctx, fields...)
		if err != nil {
			return err
		}
	}

	if bsH, ok := recordItf.(orm.HookBeforeSave); ok {
		err := bsH.BeforeSave(ctx, fields...)
		if err != nil {
			return err
		}
	}

	aiH, aiHOk := recordItf.(orm.HookAfterInsert)
	asH, asHOk := recordItf.(orm.HookAfterSave)

	columnNames := make([]string, len(fields))
	columnValues := make([]interface{}, len(fields))
	var err error
	for i, field := range fields {
		var fieldAddr interface{}
		{%= ColumnAddresses(&ColumnAddressesInput{
			FieldName: "field.Name()",
			TargetName: "fieldAddr",
			RecordName: "record",
			ErrName: "err",
			Record: record,
		}) %}
		if err != nil {
			if aiHOk {
				aiH.AfterInsert(ctx, err, fields...)
			}
			if asHOk {
				asH.AfterSave(ctx, err, fields...)
			}
			return err
		}
		columnNames[i] = field.String()
		columnValues[i] = fieldAddr
	}
	builder := store.conn.Builder().Insert({%s record.Schema.InternalRef %}.Table()).Columns(columnNames...).Values(columnValues...){% if record.FieldAutoInc != nil %}.Suffix("RETURNING {%s record.FieldAutoInc.Name %}"){% endif %}

	sql, args, err := builder.ToSql()
	if err != nil {
		if aiHOk {
			aiH.AfterInsert(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return err
	}
{% if record.FieldAutoInc == nil %}
	_, err = store.conn.ExecContext(ctx, sql, args...)

	if aiHOk {
		aiH.AfterInsert(ctx, err, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, err, fields...)
	}

	return err
{% else %}
	var id {%s record.FieldAutoInc.Type %}
	err = store.conn.QueryRowContext(ctx, sql, args...).Scan(&id)
	if err != nil {
		if aiHOk {
			aiH.AfterInsert(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return err
	}
	record.{%s record.FieldAutoInc.GoName %} = id
	if aiHOk {
		aiH.AfterInsert(ctx, nil, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, err, fields...)
	}
	return nil
{% endif %}
}

func (store *{%s record.Store.Type%}) Update(record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) (int64, error) {
	return store.UpdateContext(context.Background(), record, fields...)
}

func (store *{%s record.Store.Type%}) UpdateContext(ctx context.Context, record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) (int64, error) {
	if len(fields) == 0 {
		fields = {%s record.Schema.InternalRef %}Fields
	}

	var recordItf interface{} = record

	if buH, ok := recordItf.(orm.HookBeforeUpdate); ok {
		err := buH.BeforeUpdate(ctx, fields...)
		if err != nil {
			return 0, err
		}
	}
	
	if bsH, ok := recordItf.(orm.HookBeforeSave); ok {
		err := bsH.BeforeSave(ctx, fields...)
		if err != nil {
			return 0, err
		}
	}

	auH, auHOk := recordItf.(orm.HookAfterUpdate)
	asH, asHOk := recordItf.(orm.HookAfterSave)

	builder := store.conn.Builder().Update({%s record.Schema.InternalRef %}.Table())
	var err error
	for _, field := range fields {
		var fieldAddr interface{}
		{%= ColumnAddresses(&ColumnAddressesInput{
			FieldName: "field.Name()",
			TargetName: "fieldAddr",
			RecordName: "record",
			ErrName: "err",
			Record: record,
		}) %}
		if err != nil {
			if auHOk {
				auH.AfterUpdate(ctx, err, fields...)
			}
			if asHOk {
				asH.AfterSave(ctx, err, fields...)
			}
			return 0, err
		}
		builder = builder.Set(field.String(), fieldAddr)
	}
{% for _, field := range record.PrimaryKey %}
	builder.Where(query.Eq(query.Raw("{%j field.Name %}"), record.{%s field.GoName %}))
{% endfor %}
	r, err := builder.ExecContext(ctx)
	if err != nil {
		if auHOk {
			auH.AfterUpdate(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return 0, err
	}
	rowsAffected, err := r.RowsAffected()
	if auHOk {
		auH.AfterUpdate(ctx, err, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, err, fields...)
	}
	return rowsAffected, err
}

func (store *{%s record.Store.Type%}) Delete(records ...*{%s input.ModelsPackage.Ref(input.Package, record.Name) %}) (int64, error) {
	return store.DeleteContext(context.Background(), records...)
}

func (store *{%s record.Store.Type%}) DeleteContext(ctx context.Context, records ...*{%s input.ModelsPackage.Ref(input.Package, record.Name) %}) (int64, error) {
	builder := store.conn.Builder().Delete({%s record.Schema.InternalRef %}.Table())

	if len(records) == 0 {
		ids := make([]interface{}, len(records) * {%d len(record.PrimaryKey) %})

{% if len(record.PrimaryKey) == 1 %}
		for i, record := range records {
			var recordItf interface{} = record

			if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
				err := bdH.BeforeDelete(ctx)
				if err != nil {
					return 0, err
				}
			}
			ids[i] = record.{%s record.PrimaryKey[0].GoName %}
		}
		builder = builder.Where(query.In(query.Raw("{%j record.PrimaryKey[0].Name %}"), ids))
{% else %}
		ors := make([]sq.Sqlizer, 0, len(reocrds))
{%- for i, field := range record.PrimaryKey -%}
		field{%d i %} := query.Raw("{%j field.Name %}")
{%- endfor -%}
		for i, record := range records {
			if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
				err := bdH.BeforeDelete(ctx)
				if err != nil {
					return 0, err
				}
			}

			ors[i] = query.And(
{%- for i, field := range record.PrimaryKey -%}
				query.Eq(field{%d i %}, records[0].{%s field.GoName %}),
{%- endfor -%}
			)
		}
		builder = builder.Where(ors)
{% endif %}
	} else if len(records) == 1 {
		var recordItf interface{} = records[0]
		if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
			err := bdH.BeforeDelete(ctx)
			if err != nil {
				return 0, err
			}
		}

{% if len(record.PrimaryKey) == 1 -%}
		builder = builder.Where(query.Eq(query.Raw("{%j record.PrimaryKey[0].Name %}"), records[0].{%s record.PrimaryKey[0].GoName %}))
{% else %}
		builder = builder
{%- for _, field := range record.PrimaryKey -%}
	.Where(query.In(query.Raw("{%j field.Name %}"), records[0].{%s field.GoName %}))
{%- endfor -%}
{% endif -%}
	} else {
		return 0, nil
	}

	r, err := builder.ExecContext(ctx)
	if err != nil {
		for _, record := range records {
			var recordItf interface{} = record
			if adH, adHOk := recordItf.(orm.HookAfterDelete); adHOk {
				adH.AfterDelete(ctx, err)
			}
		}
		return 0, err
	}
	return r.RowsAffected()
}

{% endfor -%}
{% endfunc %}