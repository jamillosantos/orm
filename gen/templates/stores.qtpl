{% import "strings" %}
{% func Stores(input *StoresInput) %}
// Code generated by ormgen; DO NOT EDIT.

package {%s input.Package.Name %}

import (
	"context"
	"github.com/pkg/errors"
	
	"github.com/jamillosantos/orm"

{% if !input.ModelsPackage.Equals(input.Package) %}
	"{%s input.ModelsPackage.ImportPath %}"
{% endif %}
)

{% for _, record := range input.Records -%}
type {%s record.Store.Type %} struct {
	conn orm.ConnectionPgx
}

func New{%s record.Store.Type %}(conn orm.ConnectionPgx) *{%s record.Store.Type %} {
	return &{%s record.Store.Type %}{
		conn,
	}
}

func (store *{%s record.Store.Type%}) Insert(record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) error {
	return store.InsertContext(context.Background(), record, fields...)
}

func (store *{%s record.Store.Type%}) InsertContext(ctx context.Context, record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) error {
	if len(fields) == 0 {
		fields = {%s record.Schema.InternalRef %}Fields
	}

	var recordItf interface{} = record

	if biH, ok := recordItf.(orm.HookBeforeInsert); ok {
		err := biH.BeforeInsert(ctx, fields...)
		if err != nil {
			return err
		}
	}

	if bsH, ok := recordItf.(orm.HookBeforeSave); ok {
		err := bsH.BeforeSave(ctx, fields...)
		if err != nil {
			return err
		}
	}

	aiH, aiHOk := recordItf.(orm.HookAfterInsert)
	asH, asHOk := recordItf.(orm.HookAfterSave)

	columnNames := make([]interface{}, len(fields))
	columnValues := make([]interface{}, len(fields))
	var err error
	for i, field := range fields {
		var fieldAddr interface{}
		{%= ColumnAddresses(&ColumnAddressesInput{
			FieldName: "field.Name()",
			TargetName: "fieldAddr",
			RecordName: "record",
			ErrName: "err",
			Record: record,
		}) %}
		if err != nil {
			if aiHOk {
				aiH.AfterInsert(ctx, err, fields...)
			}
			if asHOk {
				asH.AfterSave(ctx, err, fields...)
			}
			return err
		}
		columnNames[i] = field.String()
		columnValues[i] = fieldAddr
	}
	builder := store.conn.Builder().Insert({%s record.Schema.InternalRef %}.Table(), columnNames...).Values(columnValues...){% if record.FieldAutoInc != nil %}.Returning("{%s record.FieldAutoInc.Name %}"){% endif %}

	sql, args, err := builder.ToSQL()
	if err != nil {
		if aiHOk {
			aiH.AfterInsert(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return err
	}
{% if record.FieldAutoInc == nil %}
	_, err = store.conn.Exec(ctx, sql, args...)

	if aiHOk {
		aiH.AfterInsert(ctx, err, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, err, fields...)
	}

	return err
{% else %}
	var id {%s record.FieldAutoInc.Type %}
	err = store.conn.QueryRow(ctx, sql, args...).Scan(&id)
	if err != nil {
		if aiHOk {
			aiH.AfterInsert(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return err
	}
	record.{%s record.FieldAutoInc.GoName %} = id
	if aiHOk {
		aiH.AfterInsert(ctx, nil, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, err, fields...)
	}
	return nil
{% endif %}
}

func (store *{%s record.Store.Type%}) Update(record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) (int64, error) {
	return store.UpdateContext(context.Background(), record, fields...)
}

func (store *{%s record.Store.Type%}) UpdateContext(ctx context.Context, record *{%s input.ModelsPackage.Ref(input.Package, record.Name) %}, fields ...orm.SchemaField) (int64, error) {
	if len(fields) == 0 {
		fields = {%s record.Schema.InternalRef %}Fields
	}

	var recordItf interface{} = record

	if buH, ok := recordItf.(orm.HookBeforeUpdate); ok {
		err := buH.BeforeUpdate(ctx, fields...)
		if err != nil {
			return 0, err
		}
	}
	
	if bsH, ok := recordItf.(orm.HookBeforeSave); ok {
		err := bsH.BeforeSave(ctx, fields...)
		if err != nil {
			return 0, err
		}
	}

	auH, auHOk := recordItf.(orm.HookAfterUpdate)
	asH, asHOk := recordItf.(orm.HookAfterSave)

	builder := store.conn.Builder().Update({%s record.Schema.InternalRef %}.Table())
	var err error
	for _, field := range fields {
		var fieldAddr interface{}
		{%= ColumnAddresses(&ColumnAddressesInput{
			FieldName: "field.Name()",
			TargetName: "fieldAddr",
			RecordName: "record",
			ErrName: "err",
			Record: record,
		}) %}
		if err != nil {
			if auHOk {
				auH.AfterUpdate(ctx, err, fields...)
			}
			if asHOk {
				asH.AfterSave(ctx, err, fields...)
			}
			return 0, err
		}
		builder = builder.Set(field.String(), fieldAddr)
	}
{% for _, field := range record.PrimaryKey %}
	builder.Where("{%j field.Name %} = ?", record.{%s field.GoName %})
{% endfor %}

	sql, params, err := builder.ToSQL()
	if err != nil {
		return 0, err
	}

	r, err := store.conn.Exec(ctx, sql, params...)
	if err != nil {
		if auHOk {
			auH.AfterUpdate(ctx, err, fields...)
		}
		if asHOk {
			asH.AfterSave(ctx, err, fields...)
		}
		return 0, err
	}
	rowsAffected := r.RowsAffected()
	if auHOk {
		auH.AfterUpdate(ctx, nil, fields...)
	}
	if asHOk {
		asH.AfterSave(ctx, nil, fields...)
	}
	return rowsAffected, nil
}

func (store *{%s record.Store.Type%}) Delete(records ...*{%s input.ModelsPackage.Ref(input.Package, record.Name) %}) (int64, error) {
	return store.DeleteContext(context.Background(), records...)
}

func (store *{%s record.Store.Type%}) DeleteContext(ctx context.Context, records ...*{%s input.ModelsPackage.Ref(input.Package, record.Name) %}) (int64, error) {
	builder := store.conn.Builder().Delete({%s record.Schema.InternalRef %}.Table())

	if len(records) > 1 {
		ids := make([]interface{}, len(records) * {%d len(record.PrimaryKey) %})

{% if len(record.PrimaryKey) == 1 %}
		for i, record := range records {
			var recordItf interface{} = record

			if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
				err := bdH.BeforeDelete(ctx)
				if err != nil {
					return 0, err
				}
			}
			ids[i] = record.{%s record.PrimaryKey[0].GoName %}
		}
		builder = builder.Where("{%j record.PrimaryKey[0].Name %} IN ?", ids)
{% else %}
		var (
			pkSB strings.Builder
		)

		pks := make([]interface{}, len(records) * len(record.PrimaryKey))

		for i, record := range records {
			if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
				err := bdH.BeforeDelete(ctx)
				if err != nil {
					return 0, err
				}
			}

{%- code
	var recordPkSB strings.Builder
	for i, field := range record.PrimaryKey {
		if i > 0 {
			recordPkSB.WriteString(" AND ")
		}
		recordPkSB.WriteString(field.Name)
		recordPkSB.WriteString(" = ?")
	}
 -%}
			if i > 0 {
				pkSB.WriteString(" OR ")
			}
			pkSB.WriteString("({%j recordPkSB.String() %})")
			pks = append(pks, 
{%-	for _, field := range record.PrimaryKey -%}
				records[i].{%s field.GoName %},
{%	endfor -%}
			)
		}
		builder = builder.Where(pkSB.String(), pks...)
{% endif %}
	} else if len(records) == 1 {
		var recordItf interface{} = records[0]
		if bdH, bdHOk := recordItf.(orm.HookBeforeDelete); bdHOk {
			err := bdH.BeforeDelete(ctx)
			if err != nil {
				return 0, err
			}
		}

{% if len(record.PrimaryKey) == 1 -%}
		builder = builder.Where("{%j record.PrimaryKey[0].Name %} = ?", records[0].{%s record.PrimaryKey[0].GoName %})
{% else %}
		builder
{%- for _, field := range record.PrimaryKey -%}
	.Where("{%j field.Name %} IN ", records[0].{%s field.GoName %})
{%- endfor -%}
{% endif -%}
	} else {
		return 0, nil
	}

	sql, sqlParams, err := builder.ToSQL()
	if err != nil {
		return 0, nil
	}

	r, err := store.conn.Exec(ctx, sql, sqlParams...)
	if err != nil {
		for _, record := range records {
			var recordItf interface{} = record
			if adH, adHOk := recordItf.(orm.HookAfterDelete); adHOk {
				adH.AfterDelete(ctx, err)
			}
		}
		return 0, err
	}
	return r.RowsAffected(), nil
}

{% endfor -%}
{% endfunc %}